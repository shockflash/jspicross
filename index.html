<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>FarOutFowl</title>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"></script>

  <style>
   .playfield {
     border-right: 1px solid black;
     border-bottom: 1px solid black;
     font-family: arial;

     -webkit-user-select: none;
     -khtml-user-select: none;
     -moz-user-select: none;
     -o-user-select: none;
     user-select: none;
     -webkit-user-drag: none;
   }

   .playfield td {
     border-left: 1px solid black;
     border-top: 1px solid black;
     padding: 4px;
     vertical-align: bottom;
     text-align: right;
     height: 20px;
     width: 20px;
   }

   .playfield .header {
     background-color: #FFFF99;
     width: auto;
     height: auto;
     letter-spacing: -2px;
   }

   .playfield .header.done{
     color: green;
   }

   .playfield .fifthx {
     border-right: 2px solid black;
   }

   .playfield .fifthy {
     border-bottom: 2px solid black;
   }


   .playfield .empty {
     background-color: white;
   }

   .playfield .checked {
     background-color: green;
   }

   .playfield .marked {
     background-color: #66FFCC;
   }

   .playfield .mistake {
     background-color: red;
   }


   .playfield.solved {
     border-color: gray;
   }

   .playfield.solved td {
     border-color: gray;
   }

   .playfield.solved .checked {
     background-color: green;
   }

   .playfield.solved .mistake, .playfield.solved .marked {
     background-color: white;
   }


   .modeswitch {
     margin-top: 10px;
     font-family: arial;
     font-size: 14px;
     color: gray;
   }

   .modeswitch .active {
     font-weight: bold;
     font-size: 16px;
     color: black;
   }

  </style>

</head>
<body>

  <table class="playfield" cellpadding="0" cellspacing="0">
  </table>

  <div class="modeswitch">
    <span class="active check">Check</span>
    <span class="mark">Mark</span>
  </div>

  <script>

  /**
   * Used as event manager in all classes. Every class has an own instance
   * of it. Accepts only events that are given on init.
   */
  var EventManager = function(obj, events) {
    /* allowed events of this event manager */
    this.events = events;

    /* the object related to this event handler */
    this.obj = obj;

    this.checkEvent = function(event) {
      if ($.inArray(event, this.events) == -1)
      {
        throw("Unknown event " + event);
        return;
      }
      return true;
    }

    this.bind = function(event, func) {
      if (!this.checkEvent(event))
        return;

      $(this).bind(event, func);
    }

    this.trigger = function(event, param1, param2, param3, param4) {
      if (!this.checkEvent(event))
        return;

      $(this).trigger(event, [this.obj, param1, param2, param3, param4]);
    }
  };

  var FieldModel = function(x, y, filled) {

    /* VARS */

    this.x = x;
    this.y = y;

    /* if the field is part of the drawing (true), or is empty (false) */
    this.filled = filled;

    /* if the field was checked by the user. The user sayd that this field
       is a filled field. No further action can be done with this field.
       If he was right, the Playfield shows a "Filled" field, if not a
       check-mistake is shown. 
       No field is checked at the beginning. */
    this.checked = false;

    /* if the field was marked by the user. Means that the user assumed
       that this field is filled or not filled, based on the user. The
       marking only changed the view, no further action is done. It helps
       the user to solve the puzzle */
    this.marked = false;

    /* EVENTS */

    this.events = new EventManager(this, [
        'onMarked',
        'onChecked'
      ])

    /* FUNCTIONS */

    this.getX = function() {
      return this.X;
    }

    this.getY = function() {
      return this.Y;
    }

    this.isFilled = function() {
      return this.filled;
    }

    this.isChecked = function() {
      return this.checked;
    }

    this.isMarked = function() {
      return this.marked;
    }

    this.setChecked = function() {
      /* you can not check a field two times */
      if (this.checked)
        return;

      this.checked = true;

      /* a field can only be checked or marked. Checking overwrittes marking */
      this.marked = false;

      this.events.trigger('onChecked');
    }

    this.setMarked = function(value) {
      /* you can not mark a checked field */
      if (this.checked)
        return;

      this.marked = value;

      this.events.trigger('onMarked', value);
    }

    this.toogleMarked = function() {
      this.setMarked(!this.marked);
    }
  }

  var PlayFieldModel = function() {

    /* VARS */

    this.data = {};
    this.colCount = 0;
    this.rowCount = 0;

    this.solved = false;

    /* how many fields are filled */
    this.filledCount = 0;

    /* how many of the filled fields are checked */
    this.checkedFilledCount = 0;

    /* EVENTS */

    this.events = new EventManager(this, [
        'onSolved',
      ])

    /* FUNCTIONS */

    this.init = function() {

    }

    this.setData = function(data) {
      var self = this;

      fields = data.split("\n");

      for (var y = 1; y <= fields.length; y++)
      {
        for (var x = 1; x <= fields[y-1].length; x++)
        {
          if (!this.data[x])
            this.data[x] = {};

          var value = false;
          if (fields[y-1][x-1] == 'x')
          {
            this.filledCount = this.filledCount + 1;
            value = true;
          }
          var field = new FieldModel(x, y, value);
          field.events.bind('onChecked', function(event, field) {
            self.handleOnChecked(field);
          });
          this.data[x][y] = field;
        }
      }

      /* the last values are the highest */
      this.colCount = x-1;
      this.rowCount = y-1;
    }

    this.isSolved = function() {
      return this.solved;
    }


    this.getColCount = function() {
      return this.colCount;
    }

    this.getRowCount = function() {
      return this.rowCount;
    }

    this.getColHeaders = function() {
      var result = {};

      for (var x = 1; x <= this.colCount; x++)
      {
        result[x] = [];

        var startNew = true;
        var current = 0;
        for (var y = 1; y <= this.rowCount; y++)
        {
          if (this.data[x][y].isFilled())
            current = current + 1;

          if (!this.data[x][y].isFilled() && current > 0)
          {
            result[x].push(current);
            current = 0;
          }
        }
        if (current > 0)
          result[x].push(current);
      }

      return result;
    }

    this.getRowHeaders = function() {
      var result = {};

      for (var y = 1; y <= this.rowCount; y++)
      {
        result[y] = [];

        var startNew = true;
        var current = 0;

        for (var x = 1; x <= this.colCount; x++)
        {
          if (this.data[x][y].isFilled())
            current = current + 1;

          if (!this.data[x][y].isFilled() && current > 0)
          {
            result[y].push(current);
            current = 0;
          }
        }
        if (current > 0)
          result[y].push(current);
      }

      return result;
    }

    this.getField = function(x, y) {
      return this.data[x][y];
    }


    /**
     * React on the check of a field. Count mistakes
     */
    this.handleOnChecked = function(fieldModel) {
      if (fieldModel.isFilled())
        this.checkedFilledCount = this.checkedFilledCount + 1;

      if (this.checkedFilledCount == this.filledCount)
      {
        this.solved = true;;
        this.events.trigger('onSolved');
      }
    }

    this.init();
  }

  var Field = function(x, y, element, playfield, model) {

    /* VARS */

    this.x = x;
    this.y = y;
    this.element = element;
    this.model = model;
    this.playfield = playfield;

    /* EVENTS */

    this.events = new EventManager(this, [
        'onChecked',
      ])

    /* FUNCTIONS*/

    this.init = function() {
      this.element.addClass('empty');

      if (this.x % 5 == 0 && x < this.playfield.getModel().getColCount())
        this.element.addClass('fifthx');

      if (this.y % 5 == 0 && y < this.playfield.getModel().getRowCount())
        this.element.addClass('fifthy');

      /* add event listener */
      var self = this;

      this.model.events.bind('onChecked', function(event, model) {
        self.handleOnChecked(model);
      });

      this.model.events.bind('onMarked', function(event, model, value) {
        self.handleOnMarked(model, value);
      });

      element.click(function(event) {
        self.handleClick(event);
      });

      element.mousemove(function(event) {
        if (self.playfield.getDrag())
          self.handleClick(event);
      });
    }

    this.getX = function() {
      return this.x;
    }

    this.getY = function() {
      return this.y;
    }

    this.handleOnChecked = function(model) {
      this.element.removeClass('empty marked mistake checked');
      if (model.isFilled())
      {
        this.element.addClass('checked');
      } else {
        this.element.addClass('mistake');
      }
    }

    this.handleOnMarked = function(model, value) {
      this.element.removeClass('empty marked');

      if (value)
        this.element.addClass('marked');
      else
        this.element.addClass('empty');
    }

    this.handleClick = function(event) {
      /* ignore any further clicks if playfield is solved */
      if (this.playfield.getModel().isSolved())
        return;

      if (this.playfield.getMode() == 'check')
        this.checked();

      if (this.playfield.getMode() == 'mark')
        this.marked();

    }

    this.checked = function() {
      /* you can not check a field two times */
      if (this.model.isChecked())
        return;

      this.model.setChecked();

      this.events.trigger('onChecked');
    }

    this.marked = function() {
      /* if mark is set in drag mode, we do a special handling */
      if (this.playfield.getDrag())
      {
        var mode = this.playfield.getDragMarkMode();

        if (mode == 'clear')
          this.model.setMarked(false);
        if (mode == 'set')
          this.model.setMarked(true);

        if (mode == '')
        {
          mode = 'set';
          if (this.model.isMarked())
            mode = 'clear';
          this.playfield.setDragMarkMode(mode);

          this.model.toogleMarked();
        }
      } else {
        this.model.toogleMarked();
      }
    }

    this.getModel = function() {
      return this.model;
    }

    this.init();
  }

  /**
   * Represantion of the header (cols or rows)
   */
  var Header = function(element, type, index, playFieldModel) {
    this.element = element;
    this.type = type; // col or row
    this.index = index; // col or row index of this header
    this.playFieldModel = playFieldModel;

    this.init = function() {
      this.element.addClass('header');
    }

    /**
     * Checks if a row or col is solved, so that the header
     * can mark this
     */
    this.check = function() {
      if (this.type == 'col')
        this.checkCol();
      else
        this.checkRow();
    }

    this.checkCol = function() {
      var done = true;

      var count = this.playFieldModel.getColCount();
      for (var y = 1; y <= count; y++)
      {
        var field = this.playFieldModel.getField(this.index, y);
        if (field.isFilled() && !field.isChecked())
          done = false;
      }

      if (done)
        this.element.addClass('done');
    }

    this.checkRow = function() {
      var done = true;

      var count = this.playFieldModel.getRowCount();
      for (var x = 1; x <= count; x++)
      {
        var field = this.playFieldModel.getField(x, this.index);
        if (field.isFilled() && !field.isChecked())
          done = false;
      }

      if (done)
        this.element.addClass('done');
    }

    this.init();
  }

  var PlayField = function(element, model) {
    this.element = element;
    this.model = model;
    this.fields = {};

    this.colHeaders = {};
    this.rowHeaders = {};

    this.mode = 'check';

    /* set on true on mousedown, and false on leave or up */
    this.drag = false;

    /* if marking is draged, the initial field sets the mode
         '' = no drag mode defined, the next one defines it
         'clear' = remove marks
         'set' = set marks
       */
    this.dragMarkMode = '';

    this.init = function() {
      var self = this;
      this.model.events.bind('onSolved', function(event, sender) {
        self.handleOnSolved();
      });

      element.mousedown(function() {
        self.dragMarkMode = '';
        self.drag = true;
      });

      element.mouseleave(function() {
        self.drag = false;
        self.dragMarkMode = '';
      });

      element.mouseup(function() {
        self.drag = false;
        self.dragMarkMode = '';
      });
    }

    this.getDrag = function() {
      return this.drag;
    }

    this.getDragMarkMode = function() {
      return this.dragMarkMode;
    }

    this.setDragMarkMode = function(mode) {
      if (this.drag)
        this.dragMarkMode = mode;
    }

    this.draw = function() {
      var self = this;

      var colHeader = this.model.getColHeaders();
      var rowHeader = this.model.getRowHeaders();

      /* first we draw the col headers */
      var row = $('<tr><td></td></tr>');
      for (var i = 1; i <= this.model.getColCount(); i++)
      {
        var td = $('<td>' + colHeader[i].join('<br>') + '</td>');
        row.append(td);
        this.colHeaders[i] = new Header(td, 'col', i, this.model);
      }
      this.element.append(row);

      /* now we draw the fields and the row headers */
      for (var y = 1; y <= this.model.getRowCount(); y++)
      {

        var row = $('<tr></tr>');

        /* the row header */
        var td = $('<td>' + rowHeader[y].join('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;') + '</td>');
        row.append(td);
        this.rowHeaders[y] = new Header(td, 'row', y, this.model);

        for (var x = 1; x <= this.model.getColCount(); x++)
        {
          if (!this.fields[x])
            this.fields[x] = {};

          var f = $('<td></td>');
          row.append(f);

          var field = new Field(x, y, f, this, this.model.getField(x, y));

          field.events.bind('onChecked', function(event, sender) {
            self.colHeaders[sender.getX()].check();
            self.rowHeaders[sender.getY()].check();
          });

          this.fields[x][y] = field;
        }
        this.element.append(row);
      }
    }

    this.handleOnSolved = function() {
      this.element.addClass('solved');
    }

    this.getField = function(x, y) {
      return this.fields[x][y];
    }

    this.getModel = function() {
      return this.model;
    }

    this.setMode = function(mode) {
      this.mode = mode;
    }

    this.getMode = function() {
      return this.mode;
    }


    this.init();
  }

  </script>

  <script>


     var data = "xxxxx\nxx xx\nx x x\nx x x\nxxxxx";



     var data =    "x        x\n";
     data = data + "x   x    x\n";
     data = data + "x   x    x\n";
     data = data + "x   x     \n";
     data = data + "x   x    x\n";
     data = data + "x        x\n";
     data = data + "x         \n";
     data = data + "x        x\n";
     data = data + "x        x\n";
     data = data + "x        x";



     var data =    "xxxxxxxxxxxxxxx\n";
     data = data + "xxxxx xxx xxxxx\n";
     data = data + "x            xx\n";
     data = data + "x             x\n";
     data = data + "xxxxxxxxxxxxxxx\n";

     data = data + "xxxxxxxxxxxxxxx\n";
     data = data + "xxx x xxx xxxxx\n";
     data = data + "xxxxx xxx xxxxx\n";
     data = data + "xxxxx xxx x   x\n";
     data = data + "xxxxxxxxxxxxxxx\n";

     data = data + "xxxxxxxxxxxxxxx\n";
     data = data + "xx        xxxxx\n";
     data = data + "xxxxx xxx    xx\n";
     data = data + "xxxxx xxx xxxxx\n";
     data = data + "xxxxxxxxxxxxxxx";



     var pfm = new PlayFieldModel();
     pfm.setData(data);

     pfm.events.bind('onSolved', function() {
       /* small delay to give the browser a change to draw the result for the 
          last click */
       window.setTimeout(function() {
         alert('Solved! :D');
         }, 100);
     });

     var pf = new PlayField($('.playfield'), pfm);
     pf.draw();

     $('.modeswitch .mark').click(function() {
       $(this).toggleClass('active');
       $('.modeswitch .check').toggleClass('active');

      pf.setMode('mark');
     });

     $('.modeswitch .check').click(function() {
       $(this).toggleClass('active');
       $('.modeswitch .mark').toggleClass('active');

      pf.setMode('check');
     });

  </script>

</body>
</html>
